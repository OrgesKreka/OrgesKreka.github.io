

var koka ="                                \/****************************\r\n                                 *   Shkruaj si hakerr!      *\r\n                                 *        @Orges Kreka      *\r\n                                 ****************************/\n\n";
//var KODI = 'from page_dewarp import *\r\n\r\ndef make_params(rvec, tvec, cubic_slopes):\r\n    return np.hstack((rvec.flatten(),\r\n                      tvec.flatten(),\r\n                      cubic_slopes.flatten()))\r\n\r\ndef lerp(a, b, u):\r\n    return a + u * (b-a)\r\n\r\ndef cspline(x):\r\n    return 3*x**2 - 2*x**3\r\n\r\ndef subdivide(points, is_closed, tol=None):\r\n\r\n    output = []\r\n    \r\n    if tol is None:\r\n        tol = 0.02\r\n\r\n    for i, point_i in enumerate(points):\r\n        j = i + 1\r\n        if j >= len(points):\r\n            if is_closed:\r\n               j = 0\r\n            else:\r\n                output.append(point_j)\r\n                break\r\n        point_j = points[j]\r\n        dist = np.linalg.norm(point_j - point_i)\r\n        count = int(np.ceil(dist \/ tol))\r\n        for k in range(count):\r\n            u = float(k)\/count\r\n            output.append(lerp(point_i, point_j, u))\r\n\r\n    output = np.array(output)\r\n\r\n    return output\r\n\r\ndef add_paragraph(lc, starty, startx, width, count,\r\n                  indent=0.0, spacing=None, lastwidth=None, tol=None):\r\n\r\n    if starty is None:\r\n        starty = line_coords[-1][-1,1] + spacing\r\n\r\n    if lastwidth is None:\r\n        lastwidth = width\r\n\r\n    if spacing is None:\r\n        spacing = 0.1\r\n\r\n    y = starty\r\n\r\n    for i in range(count):\r\n        if i+1 == count:\r\n            w = lastwidth\r\n        else:\r\n            w = width\r\n        if i == 0:\r\n            x = startx + indent\r\n            w -= indent\r\n        else:\r\n            x = startx\r\n\r\n        segment = np.array([\r\n            [ x, y ],\r\n            [ x+w, y ]])\r\n\r\n        lc.append(subdivide(segment, False))\r\n        y += spacing\r\n\r\nheight = 512\r\nwidth = height*3\/4\r\n\r\ndisplay = np.zeros((height, width), dtype=np.uint8)\r\n\r\naspect = float(width)\/height\r\n\r\npage_width = aspect\r\npage_height = 1.0\r\n\r\n# top left norm should be (-1.0, -a)\r\n# bottom right norm should be (1, a)\r\n\r\nz = 0.5 * FOCAL_LENGTH\r\n\r\n# rvec, tvec, cubic_slopes, ycoords, xcoords\r\nparam_vecs = [\r\n    (np.array([0.0, 0.0, 0.0]),\r\n     np.array([-0.5*page_width, -0.5*page_height, 1.02*z]),\r\n     np.array([0.0, 0.0])),\r\n\r\n    (np.array([-0.12, 0.0, 0.0]),\r\n     np.array([-0.5*page_width, -0.5*page_height-0.03, 1.35*z]),\r\n     np.array([-1.0, -0.5])),\r\n\r\n    (np.array([-0.14, -0.1, 0.08]),\r\n     np.array([-0.5*page_width+0.04, -0.5*page_height-0.05, 1.5*z]),\r\n     np.array([-1.5, 0.0])),\r\n\r\n    (np.array([-0.18, -0.2, 0.0]),\r\n     np.array([-0.5*page_width-0.05, -0.5*page_height-0.03, 1.45*z]),\r\n     np.array([-1.0, 1.0])),\r\n\r\n    (np.array([0.1, 0.1, 0.0]),\r\n     np.array([-0.5*page_width-0.05, -0.5*page_height+0.03, 1.2*z]),\r\n     np.array([-1.0, -1.0]))\r\n]\r\n\r\nparam_vecs = [ np.hstack(i) for i in param_vecs ]\r\n\r\noutline_coords = np.array([\r\n    [0, 0],\r\n    [page_width, 0],\r\n    [page_width, page_height],\r\n    [0, page_height]])\r\n\r\noutline_coords = subdivide(outline_coords, True)\r\n\r\nline_coords = []\r\n\r\nadd_paragraph(line_coords, 0.2, 0.3, page_width-0.5, 2, -0.1, 0.03, page_width-0.6)\r\nadd_paragraph(line_coords, 0.3, 0.1, page_width-0.2, 5, 0.05, 0.03, 0.3)\r\nadd_paragraph(line_coords, None, 0.1, page_width-0.2, 7, 0.05, 0.03, 0.5)\r\nadd_paragraph(line_coords, None, 0.1, page_width-0.2, 3, 0.05, 0.03, 0.35)\r\nadd_paragraph(line_coords, None, 0.1, page_width-0.2, 4, 0.05, 0.03, 0.4)\r\n\r\nwindow = \'Visualize\'\r\ncv2.namedWindow(window)\r\n';


var KODI = 'import unittest\nimport os\nimport sys\n\timport os.path\n\timport traceback\n\n\n\tclass _WritelnDecorator(object):\n\t    \"\"\"Used to decorate file-like objects with a handy \'writeln\' method\"\"\"\n\t    def __init__(self,stream):\n\t        self.stream = stream\n\n\t   def __getattr__(self, attr):\n\t        if attr in (\'stream\', \'__getstate__\'):\n            raise AttributeError(attr)\n        return getattr(self.stream,attr)\n\n    def writeln(self, arg=None):\n        if arg:\n            self.write(arg)\n        self.write(\'\\n\') # text-mode streams translate to \\r\\n if needed\n\n\nclass TextTestResult(unittest.TestResult):\n    \"\"\"A test result class that can print formatted text results to a stream.\n\n    Used by TextTestRunner.\n    \"\"\"\n    separator1 = \'=\' * 70\n    separator2 = \'-\' * 70\n\n    def __init__(self, stream, descriptions, verbosity):\n        super(TextTestResult, self).__init__()\n        self.stream = stream\n        self.showAll = verbosity > 1\n        self.dots = verbosity == 1\n        self.descriptions = descriptions\n\n    def getDescription(self, test):\n        doc_first_line = test.shortDescription()\n        if self.descriptions and doc_first_line:\n            return \'\\n\'.join((str(test), doc_first_line))\n        else:\n            return str(test)\n\n    def startTest(self, test):\n        super(TextTestResult, self).startTest(test)\n        if self.showAll:\n            self.stream.write(self.getDescription(test))\n            self.stream.write(\" ... \")\n            self.stream.flush()\n\n    def addSuccess(self, test):\n        super(TextTestResult, self).addSuccess(test)\n        if self.showAll:\n            self.stream.writeln(\"ok\")\n        elif self.dots:\n            self.stream.write(\'.\')\n            self.stream.flush()\n\n    def addError(self, test, err):\n        super(TextTestResult, self).addError(test, err)\n        if self.showAll:\n            self.stream.writeln(\"ERROR\")\n        elif self.dots:\n            self.stream.write(\'E\')\n            self.stream.flush()\n\n    def addFailure(self, test, err):\n        super(TextTestResult, self).addFailure(test, err)\n        if self.showAll:\n            self.stream.writeln(\"FAIL\")\n        elif self.dots:\n            self.stream.write(\'F\')\n            self.stream.flush()\n\n    def addSkip(self, test, reason):\n        super(TextTestResult, self).addSkip(test, reason)\n        if self.showAll:\n            self.stream.writeln(\"skipped {0!r}\".format(reason))\n        elif self.dots:\n            self.stream.write(\"s\")\n            self.stream.flush()\n\n    def addExpectedFailure(self, test, err):\n        super(TextTestResult, self).addExpectedFailure(test, err)\n        if self.showAll:\n            self.stream.writeln(\"expected failure\")\n        elif self.dots:\n            self.stream.write(\"x\")\n            self.stream.flush()\n\n    def addUnexpectedSuccess(self, test):\n        super(TextTestResult, self).addUnexpectedSuccess(test)\n        if self.showAll:\n            self.stream.writeln(\"unexpected success\")\n        elif self.dots:\n            self.stream.write(\"u\")\n            self.stream.flush()\n\n    def printErrors(self):\n        if self.dots or self.showAll:\n            self.stream.writeln()\n        self.printErrorList(\'ERROR\', self.errors)\n        self.printErrorList(\'FAIL\', self.failures)\n\n    def printErrorList(self, flavour, errors):\n        for test, err in errors:\n            self.stream.writeln(self.separator1)\n            self.stream.writeln(\"%s: %s\" % (flavour,self.getDescription(test)))\n            self.stream.writeln(self.separator2)\n            self.stream.writeln(\"%s\" % err)\n\n\nclass TextTestRunner(object):\n    \"\"\"A test runner class that displays results in textual form.\n\n    It prints out the names of tests as they are run, errors as they\n    occur, and a summary of the results at the end of the test run.\n    \"\"\"\n    resultclass = TextTestResult\n\n    def __init__(self, stream=None, descriptions=True, verbosity=1,\n                 failfast=False, buffer=False, resultclass=None, warnings=None):\n        if stream is None:\n            stream = sys.stderr\n        self.stream = _WritelnDecorator(stream)\n        self.descriptions = descriptions\n        self.verbosity = verbosity\n        self.failfast = failfast\n        self.buffer = buffer\n        self.warnings = warnings\n        if resultclass is not None:\n            self.resultclass = resultclass\n\n    def _makeResult(self):\n        return self.resultclass(self.stream, self.descriptions, self.verbosity)\n\n    def run(self, test):\n        \"Run the given test case or test suite.\"\n        result = self._makeResult()\n        registerResult(result)\n        result.failfast = self.failfast\n        result.buffer = self.buffer\n        with warnings.catch_warnings():\n            if self.warnings:\n                # if self.warnings is set, use it to filter all the warnings\n                warnings.simplefilter(self.warnings)\n                # if the filter is \'default\' or \'always\', special-case the\n                # warnings from the deprecated unittest methods to show them\n                # no more than once per module, because they can be fairly\n                # noisy.  The -Wd and -Wa flags can be used to bypass this\n                # only when self.warnings is None.\n                if self.warnings in [\'default\', \'always\']:\n                    warnings.filterwarnings(\'module\',\n                            category=DeprecationWarning,\n                            message=\'Please use assert\\w+ instead.\')\n            startTime = time.time()\n            startTestRun = getattr(result, \'startTestRun\', None)\n            if startTestRun is not None:\n                startTestRun()\n            try:\n                test(result)\n            finally:\n                stopTestRun = getattr(result, \'stopTestRun\', None)\n                if stopTestRun is not None:\n                    stopTestRun()\n            stopTime = time.time()\n        timeTaken = stopTime - startTime\n        result.printErrors()\n        if hasattr(result, \'separator2\'):\n            self.stream.writeln(result.separator2)\n        run = result.testsRun\n        self.stream.writeln(\"Ran %d test%s in %.3fs\" %\n                            (run, run != 1 and \"s\" or \"\", timeTaken))\n        self.stream.writeln()\n\n        expectedFails = unexpectedSuccesses = skipped = 0\n        try:\n            results = map(len, (result.expectedFailures,\n                                result.unexpectedSuccesses,\n                                result.skipped))\n        except AttributeError:\n            pass\n        else:\n            expectedFails, unexpectedSuccesses, skipped = results\n\n        infos = []\n        if not result.wasSuccessful():\n            self.stream.write(\"FAILED\")\n            failed, errored = len(result.failures), len(result.errors)\n            if failed:\n                infos.append(\"failures=%d\" % failed)\n            if errored:\n                infos.append(\"errors=%d\" % errored)\n        else:\n            self.stream.write(\"OK\")\n        if skipped:\n            infos.append(\"skipped=%d\" % skipped)\n        if expectedFails:\n            infos.append(\"expected failures=%d\" % expectedFails)\n        if unexpectedSuccesses:\n            infos.append(\"unexpected successes=%d\" % unexpectedSuccesses)\n        if infos:\n            self.stream.writeln(\" (%s)\" % (\", \".join(infos),))\n        else:\n            self.stream.write(\"\\n\")\n        return result\n\nclass Result(unittest.TestResult):\n    def addSuccess(self, test):\n        pass\n        #print(\"Running test: \", test, \"successfull\")\n\n    def addFailure(self, test, err):\n        print(\"Failure: \", test, err)\n        unittest.TestResult.addFailure(self, test, err)\n        typ, value, tb = err\n        print(typ, value)\n        traceback.print_tb(tb)\n\n    def addError(self, test, err):\n        print(\"Error: \", test, err)\n        unittest.TestResult.addFailure(self, test, err)\n        typ, value, tb = err\n        print(typ, value)\n        traceback.print_tb(tb)\n\nif __name__ == \"__main__\":\n    testloader = unittest.TestLoader()\n    testsuite = testloader.loadTestsFromNames(\n        [\"test_opts\", \n         \"test_import\", \n         \"test_com\", \n         \"test_shareddict\",\n         \"test_snapshotting\", \n         \"test_debugger\", \n         \"test_breakpoint\",\n         \"test_basedebugger\"])\n    result = TextTestResult(_WritelnDecorator(sys.stdout), True, 2)\n    testsuite.run(result)';